#include <SPI.h>
#include "Common.h"
#include "DW1000Ranging.h"
#include "DW1000.h"

// ========== é…ç½®é€‰é¡¹ ==========
// #define TAG_MODE
// #define ANCHOR_MODE
// #define CALIBRATE_MODE
// #define Ranging_TAG
#define Ranging_ANCHOR

// ========== è®¾å¤‡å‚æ•° ==========
#ifdef TAG_MODE
// currently tag is module #5
// The purpose of this code is to set the tag address and antenna delay to default.
// this tag will be used for calibrating the anchors.

// TAG antenna delay defaults to 16384
// leftmost two bytes below will become the "short address"
char tag_addr[] = "7D:00:22:EA:82:60:3B:9C";

void newRange() {
  Serial.print(DW1000Ranging.getDistantDevice()->getShortAddress(), HEX);
  Serial.print(",");
  Serial.println(DW1000Ranging.getDistantDevice()->getRange());
}

void newDevice(DW1000Device* device) {
  Serial.print("Device added: ");
  Serial.println(device->getShortAddress(), HEX);
}

void inactiveDevice(DW1000Device* device) {
  Serial.print("delete inactive device: ");
  Serial.println(device->getShortAddress(), HEX);
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  //init the configuration
  SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI);
  DW1000Ranging.initCommunication(UWB_RST, UWB_CS, UWB_IRQ);

  DW1000Ranging.attachNewRange(newRange);
  DW1000Ranging.attachNewDevice(newDevice);
  DW1000Ranging.attachInactiveDevice(inactiveDevice);

  // start as tag, do not assign random short address

  DW1000Ranging.startAsTag(tag_addr, DW1000.MODE_LONGDATA_RANGE_LOWPOWER, false);
}

void loop() {
  DW1000Ranging.loop();
}
#elif ANCHOR_MODE
//anchor #4 setup

// be sure to edit anchor_addr and select the previously calibrated anchor delay
// my naming convention is anchors 1, 2, 3, ... have the lowest order byte of the MAC address set to 81, 82, 83, ...

// leftmost two bytes below will become the "short address"
char anchor_addr[] = "84:00:5B:D5:A9:9A:E2:9C"; //#4

//calibrated Antenna Delay setting for this anchor
uint16_t Adelay = 16050;

// previously determined calibration results for antenna delay
// #1 16630
// #2 16610
// #3 16607
// #4 16580

// calibration distance
float dist_m = (285 - 1.75) * 0.0254; //meters

void newRange() {
  //    Serial.print("from: ");
  Serial.print(DW1000Ranging.getDistantDevice()->getShortAddress(), HEX);
  Serial.print(", ");

#define NUMBER_OF_DISTANCES 1
  float dist = 0.0;
  for (int i = 0; i < NUMBER_OF_DISTANCES; i++) {
    dist += DW1000Ranging.getDistantDevice()->getRange();
  }
  dist = dist / NUMBER_OF_DISTANCES;
  Serial.println(dist);
}

void newDevice(DW1000Device* device) {
  Serial.print("Device added: ");
  Serial.println(device->getShortAddress(), HEX);
}

void inactiveDevice(DW1000Device* device) {
  Serial.print("Delete inactive device: ");
  Serial.println(device->getShortAddress(), HEX);
}

void setup() {
  Serial.begin(115200);
  delay(1000); //wait for serial monitor to connect
  Serial.println("Anchor config and start");
  Serial.print("Antenna delay ");
  Serial.println(Adelay);
  Serial.print("Calibration distance ");
  Serial.println(dist_m);

  //init the configuration
  SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI);
  DW1000Ranging.initCommunication(UWB_RST, UWB_CS, UWB_IRQ);

  // set antenna delay for anchors only. Tag is default (16384)
  DW1000.setAntennaDelay(Adelay);

  DW1000Ranging.attachNewRange(newRange);
  DW1000Ranging.attachNewDevice(newDevice);
  DW1000Ranging.attachInactiveDevice(inactiveDevice);

  //start the module as an anchor, do not assign random short address
  DW1000Ranging.startAsAnchor(anchor_addr, DW1000.MODE_LONGDATA_RANGE_LOWPOWER, false);
  // DW1000Ranging.startAsAnchor(ANCHOR_ADD, DW1000.MODE_SHORTDATA_FAST_LOWPOWER);
  // DW1000Ranging.startAsAnchor(ANCHOR_ADD, DW1000.MODE_LONGDATA_FAST_LOWPOWER);
  // DW1000Ranging.startAsAnchor(ANCHOR_ADD, DW1000.MODE_SHORTDATA_FAST_ACCURACY);
  // DW1000Ranging.startAsAnchor(ANCHOR_ADD, DW1000.MODE_LONGDATA_FAST_ACCURACY);
  // DW1000Ranging.startAsAnchor(ANCHOR_ADD, DW1000.MODE_LONGDATA_RANGE_ACCURACY);
}

void loop() {
  DW1000Ranging.loop();
}
#elif CALIBRATE_MODE
char this_anchor_addr[] = "84:00:22:EA:82:60:3B:9C";
uint16_t this_anchor_Adelay = 15000; //starting value

// ========== æ ¡å‡†å˜é‡ ==========
const float CALIBRATION_DISTANCE = 1.0; // å®é™…æµ‹é‡è·ç¦»
const uint8_t CALIBRATION_SAMPLES = 50; // æ¯æ¬¡æ ¡å‡†é‡‡æ ·æ•°
float calibrationReadings[CALIBRATION_SAMPLES];
uint8_t sampleCount = 0;
bool calibrationActive = false;
bool calibrationComplete = false;
uint32_t calibrationStartTime = 0;

// ========== æ ¡å‡†ç»“æœ ==========
float averageMeasuredDistance = 0;
float calibrationError = 0;
uint16_t recommendedDelay = 0;

// ========== æ ¡å‡†å‡½æ•° ==========
void startCalibration() {
  Serial.println("\nğŸ¯ ===== å¼€å§‹å¤©çº¿å»¶è¿Ÿæ ¡å‡† =====");
  Serial.print("ğŸ“ ç›®æ ‡è·ç¦»: ");
  Serial.print(CALIBRATION_DISTANCE, 3);
  Serial.println(" ç±³");
  Serial.print("â±ï¸ å½“å‰å¤©çº¿å»¶è¿Ÿ: ");
  Serial.println(this_anchor_Adelay);
  Serial.println("ğŸ“ è¯·ç¡®ä¿Tagæ”¾ç½®åœ¨å‡†ç¡®è·ç¦»å¤„ï¼Œç„¶åæŒ‰ä»»æ„é”®å¼€å§‹...");

  while (!Serial.available()) {
    delay(100);
  }
  Serial.read(); // æ¸…é™¤ç¼“å†²åŒº

  calibrationActive = true;
  calibrationComplete = false;
  sampleCount = 0;
  calibrationStartTime = millis();

  Serial.println("ğŸ”¬ å¼€å§‹é‡‡é›†æ ¡å‡†æ•°æ®...");
}

void printCalibrationResults() {
  Serial.println("\nâœ… ===== æ ¡å‡†å®Œæˆ =====");
  Serial.print("ğŸ“ ç›®æ ‡è·ç¦»: ");
  Serial.print(CALIBRATION_DISTANCE, 3);
  Serial.println(" ç±³");
  Serial.print("ğŸ“ æµ‹é‡å¹³å‡è·ç¦»: ");
  Serial.print(averageMeasuredDistance, 3);
  Serial.println(" ç±³");
  Serial.print("ğŸ“ˆ æµ‹é‡è¯¯å·®: ");
  Serial.print(calibrationError, 3);
  Serial.println(" ç±³");
  Serial.print("âš™ï¸ å½“å‰å¤©çº¿å»¶è¿Ÿ: ");
  Serial.println(this_anchor_Adelay);
  Serial.print("ğŸ’¡ æ¨èå¤©çº¿å»¶è¿Ÿ: ");
  Serial.println(recommendedDelay);
  Serial.print("ğŸ”§ è°ƒæ•´é‡: ");
  Serial.println(recommendedDelay - this_anchor_Adelay);
  Serial.println("============================\n");

  Serial.println("ğŸ’¾ è¯·å°†æ¨èå€¼æ›´æ–°åˆ°ä»£ç ä¸­çš„ ANTENNA_DELAY å¸¸é‡");
  Serial.println("ğŸ”„ æŒ‰ 'r' é‡æ–°æ ¡å‡†ï¼ŒæŒ‰ 'a' åº”ç”¨æ–°å»¶è¿Ÿå¹¶æµ‹è¯•");
}

void completeCalibration() {
  // è®¡ç®—å¹³å‡å€¼
  float sum = 0;
  for (uint8_t i = 0; i < CALIBRATION_SAMPLES; i++) {
    sum += calibrationReadings[i];
  }
  averageMeasuredDistance = sum / CALIBRATION_SAMPLES;

  // è®¡ç®—è¯¯å·®
  calibrationError = averageMeasuredDistance - CALIBRATION_DISTANCE;

  // è®¡ç®—æ¨èå»¶è¿Ÿï¼ˆç»éªŒå…¬å¼ï¼‰
  // æ¯ç±³è¯¯å·®çº¦éœ€è¦è°ƒæ•´ 200-300 ä¸ªå»¶è¿Ÿå•ä½
  int16_t delayAdjustment = (int16_t)(calibrationError * 250);
  recommendedDelay = this_anchor_Adelay - delayAdjustment;

  // é™åˆ¶å»¶è¿Ÿåœ¨åˆç†èŒƒå›´å†…
  if (recommendedDelay < 15000) recommendedDelay = 15000;
  if (recommendedDelay > 18000) recommendedDelay = 18000;

  calibrationActive = false;
  calibrationComplete = true;

  printCalibrationResults();
}

void processCalibrationSample(float distance) {
  if (!calibrationActive || calibrationComplete) return;

  // è¿‡æ»¤å¼‚å¸¸å€¼
  if (distance < 0 || distance > 10.0) {
    Serial.print("âŒ æ— æ•ˆæµ‹é‡å€¼: ");
    Serial.println(distance);
    return;
  }

  calibrationReadings[sampleCount] = distance;
  sampleCount++;

  Serial.print("ğŸ“Š é‡‡æ · ");
  Serial.print(sampleCount);
  Serial.print("/");
  Serial.print(CALIBRATION_SAMPLES);
  Serial.print(": ");
  Serial.print(distance, 3);
  Serial.println(" ç±³");

  if (sampleCount >= CALIBRATION_SAMPLES) {
    completeCalibration();
  }
}

void applyCalibration() {
  if (!calibrationComplete) {
    Serial.println("âŒ è¯·å…ˆå®Œæˆæ ¡å‡†");
    return;
  }

  this_anchor_Adelay = recommendedDelay;
  DW1000.setAntennaDelay(this_anchor_Adelay);

  Serial.print("âœ… å·²åº”ç”¨æ–°å»¶è¿Ÿ: ");
  Serial.println(this_anchor_Adelay);
  Serial.println("ğŸ”„ é‡æ–°å¼€å§‹æ ¡å‡†ä»¥æµ‹è¯•æ–°è®¾ç½®...");

  // é‡ç½®æ ¡å‡†çŠ¶æ€
  calibrationComplete = false;
}

// ========== æµ‹è·å›è°ƒå‡½æ•° ==========
void handleNewRange() {
  float distance = DW1000Ranging.getDistantDevice()->getRange();

  if (calibrationActive) {
    processCalibrationSample(distance);
  } else {
    Serial.print("ğŸ“ Anchor -> Tag: ");
    Serial.print(distance, 3);
    Serial.print("m, Delay: ");
    Serial.print(this_anchor_Adelay);
    Serial.print(", Power: ");
    Serial.print(DW1000Ranging.getDistantDevice()->getRXPower(), 1);
    Serial.println("dBm");
  }
}

void handleNewDevice(DW1000Device* device) {
  Serial.print("ğŸ“± æ£€æµ‹åˆ°Tag: 0x");
  Serial.println(device->getShortAddress(), HEX);
}

void handleInactiveDevice(DW1000Device* device) {
  Serial.print("âš¡ Tagæ–­å¼€: 0x");
  Serial.println(device->getShortAddress(), HEX);
}

// ========== åˆå§‹åŒ–å‡½æ•° ==========
void initializeAnchor() {
  //init the configuration
  SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI);
  DW1000Ranging.initCommunication(UWB_RST, UWB_CS, UWB_IRQ);


  Serial.print("Starting Adelay "); Serial.println(this_anchor_Adelay);
  Serial.print("Measured distance "); Serial.println(CALIBRATION_DISTANCE);

  DW1000.setAntennaDelay(this_anchor_Adelay);

  DW1000Ranging.attachNewRange(handleNewRange);
  DW1000Ranging.attachNewDevice(handleNewDevice);
  DW1000Ranging.attachInactiveDevice(handleInactiveDevice);
  //Enable the filter to smooth the distance
  //DW1000Ranging.useRangeFilter(true);

  //start the module as anchor, don't assign random short address
  DW1000Ranging.startAsAnchor(this_anchor_addr, DW1000.MODE_LONGDATA_RANGE_LOWPOWER, false);

}

void printMenu() {
  Serial.println("\nğŸ“‹ å‘½ä»¤èœå•:");
  Serial.println("s - å¼€å§‹æ ¡å‡†");
  Serial.println("r - é‡æ–°å¼€å§‹æ ¡å‡†");
  Serial.println("a - åº”ç”¨æ¨èå»¶è¿Ÿ");
  Serial.println("c - å½“å‰çŠ¶æ€");
  Serial.println("m - æ˜¾ç¤ºèœå•");
  Serial.println("========================");
}

void handleSerialCommands() {
  if (Serial.available()) {
    char command = Serial.read();

    switch (command) {
    case 's':
    case 'S':
      if (!calibrationActive) {
        startCalibration();
      }
      break;

    case 'r':
    case 'R':
      calibrationActive = false;
      calibrationComplete = false;
      startCalibration();
      break;

    case 'a':
    case 'A':
      applyCalibration();
      break;

    case 'c':
    case 'C':
      Serial.print("ğŸ“Š å½“å‰çŠ¶æ€ - å»¶è¿Ÿ: ");
      Serial.print(this_anchor_Adelay);
      Serial.print(", æ ¡å‡†: ");
      Serial.println(calibrationActive ? "è¿›è¡Œä¸­" : (calibrationComplete ? "å®Œæˆ" : "æœªå¼€å§‹"));
      break;

    case 'm':
    case 'M':
      printMenu();
      break;

    default:
      Serial.println("â“ æœªçŸ¥å‘½ä»¤ï¼ŒæŒ‰ 'm' æ˜¾ç¤ºèœå•");
      break;
    }
  }
}

// ========== Arduinoæ ‡å‡†å‡½æ•° ==========
void setup() {
  Serial.begin(115200);
  delay(3000); // ç­‰å¾…ä¸²å£è¿æ¥

  Serial.println("ğŸ¯ UWBå¤©çº¿å»¶è¿Ÿæ ¡å‡†ç¨‹åº");
  Serial.println("========================");

  initializeAnchor();

  // æ˜¾ç¤ºèœå•
  printMenu();
}

void loop() {
  DW1000Ranging.loop();
  handleSerialCommands();

  // æ˜¾ç¤ºè¿›åº¦
  static uint32_t lastUpdate = 0;
  if (calibrationActive && millis() - lastUpdate > 1000) {
    Serial.print("â³ æ ¡å‡†è¿›åº¦: ");
    Serial.print(sampleCount);
    Serial.print("/");
    Serial.print(CALIBRATION_SAMPLES);
    Serial.println(" é‡‡æ ·");
    lastUpdate = millis();
  }
}
#elif defined(Ranging_ANCHOR)

// messages used in the ranging protocol
// TODO replace by enum
#define POLL 0
#define POLL_ACK 1
#define RANGE 2
#define RANGE_REPORT 3
#define RANGE_FAILED 255
// message flow state
volatile byte expectedMsgId = POLL;
// message sent/received state
volatile boolean sentAck = false;
volatile boolean receivedAck = false;
// protocol error state
boolean protocolFailed = false;
// timestamps to remember
DW1000Time timePollSent;
DW1000Time timePollReceived;
DW1000Time timePollAckSent;
DW1000Time timePollAckReceived;
DW1000Time timeRangeSent;
DW1000Time timeRangeReceived;
// last computed range/time
DW1000Time timeComputedRange;
// data buffer
#define LEN_DATA 16
byte data[LEN_DATA];
// watchdog and reset period
uint32_t lastActivity;
uint32_t resetPeriod = 250;
// reply times (same on both sides for symm. ranging)
uint16_t replyDelayTimeUS = 3000;
// ranging counter (per second)
uint16_t successRangingCount = 0;
uint32_t rangingCountPeriod = 0;
float samplingRate = 0;

void noteActivity() {
    // update activity timestamp, so that we do not reach "resetPeriod"
    lastActivity = millis();
}

void receiver() {
    DW1000.newReceive();
    DW1000.setDefaults();
    // so we don't need to restart the receiver manually
    DW1000.receivePermanently(true);
    DW1000.startReceive();
}

void resetInactive() {
    // anchor listens for POLL
    expectedMsgId = POLL;
    receiver();
    noteActivity();
}

void handleSent() {
    // status change on sent success
    sentAck = true;
}

void handleReceived() {
    // status change on received success
    receivedAck = true;
}

void transmitPollAck() {
    DW1000.newTransmit();
    DW1000.setDefaults();
    data[0] = POLL_ACK;
    // delay the same amount as ranging tag
    DW1000Time deltaTime = DW1000Time(replyDelayTimeUS, DW1000Time::MICROSECONDS);
    DW1000.setDelay(deltaTime);
    DW1000.setData(data, LEN_DATA);
    DW1000.startTransmit();
}

void transmitRangeReport(float curRange) {
    DW1000.newTransmit();
    DW1000.setDefaults();
    data[0] = RANGE_REPORT;
    // write final ranging result
    memcpy(data + 1, &curRange, 4);
    DW1000.setData(data, LEN_DATA);
    DW1000.startTransmit();
}

void transmitRangeFailed() {
    DW1000.newTransmit();
    DW1000.setDefaults();
    data[0] = RANGE_FAILED;
    DW1000.setData(data, LEN_DATA);
    DW1000.startTransmit();
}

/*
 * RANGING ALGORITHMS
 * ------------------
 * Either of the below functions can be used for range computation (see line "CHOSEN
 * RANGING ALGORITHM" in the code).
 * - Asymmetric is more computation intense but least error prone
 * - Symmetric is less computation intense but more error prone to clock drifts
 *
 * The anchors and tags of this reference example use the same reply delay times, hence
 * are capable of symmetric ranging (and of asymmetric ranging anyway).
 */

void computeRangeAsymmetric() {
    // asymmetric two-way ranging (more computation intense, less error prone)
    DW1000Time round1 = (timePollAckReceived - timePollSent).wrap();
    DW1000Time reply1 = (timePollAckSent - timePollReceived).wrap();
    DW1000Time round2 = (timeRangeReceived - timePollAckSent).wrap();
    DW1000Time reply2 = (timeRangeSent - timePollAckReceived).wrap();
    DW1000Time tof = (round1 * round2 - reply1 * reply2) / (round1 + round2 + reply1 + reply2);
    // set tof timestamp
    timeComputedRange.setTimestamp(tof);
}

void computeRangeSymmetric() {
    // symmetric two-way ranging (less computation intense, more error prone on clock drift)
    DW1000Time tof = ((timePollAckReceived - timePollSent) - (timePollAckSent - timePollReceived) +
                      (timeRangeReceived - timePollAckSent) - (timeRangeSent - timePollAckReceived)) * 0.25f;
    // set tof timestamp
    timeComputedRange.setTimestamp(tof);
}

/*
 * END RANGING ALGORITHMS
 * ----------------------
 */

void setup() {
    // DEBUG monitoring
    Serial.begin(115200);
    delay(1000);
    Serial.println(F("### DW1000-arduino-ranging-anchor ###"));
    // initialize the driver
    DW1000.begin(UWB_IRQ, UWB_RST);
    DW1000.select(UWB_CS);
    Serial.println(F("DW1000 initialized ..."));
    // general configuration
    DW1000.newConfiguration();
    DW1000.setDefaults();
    DW1000.setDeviceAddress(1);
    DW1000.setNetworkId(10);
    DW1000.enableMode(DW1000.MODE_LONGDATA_RANGE_LOWPOWER);
    DW1000.commitConfiguration();
    Serial.println(F("Committed configuration ..."));
    // DEBUG chip info and registers pretty printed
    char msg[128];
    DW1000.getPrintableDeviceIdentifier(msg);
    Serial.print("Device ID: "); Serial.println(msg);
    DW1000.getPrintableExtendedUniqueIdentifier(msg);
    Serial.print("Unique ID: "); Serial.println(msg);
    DW1000.getPrintableNetworkIdAndShortAddress(msg);
    Serial.print("Network ID & Device Address: "); Serial.println(msg);
    DW1000.getPrintableDeviceMode(msg);
    Serial.print("Device mode: "); Serial.println(msg);
    // attach callback for (successfully) sent and received messages
    DW1000.attachSentHandler(handleSent);
    DW1000.attachReceivedHandler(handleReceived);
    // anchor starts in receiving mode, awaiting a ranging poll message
    receiver();
    noteActivity();
    // for first time ranging frequency computation
    rangingCountPeriod = millis();
}

void loop() {
    int32_t curMillis = millis();
    if (!sentAck && !receivedAck) {
        // check if inactive
        if (curMillis - lastActivity > resetPeriod) {
            resetInactive();
        }
        return;
    }
    // continue on any success confirmation
    if (sentAck) {
        sentAck = false;
        byte msgId = data[0];
        if (msgId == POLL_ACK) {
            DW1000.getTransmitTimestamp(timePollAckSent);
            noteActivity();
        }
    }
    if (receivedAck) {
        receivedAck = false;
        // get message and parse
        DW1000.getData(data, LEN_DATA);
        byte msgId = data[0];
        if (msgId != expectedMsgId) {
            // unexpected message, start over again (except if already POLL)
            protocolFailed = true;
        }
        if (msgId == POLL) {
            // on POLL we (re-)start, so no protocol failure
            protocolFailed = false;
            DW1000.getReceiveTimestamp(timePollReceived);
            expectedMsgId = RANGE;
            transmitPollAck();
            noteActivity();
        }
        else if (msgId == RANGE) {
            DW1000.getReceiveTimestamp(timeRangeReceived);
            expectedMsgId = POLL;
            if (!protocolFailed) {
                timePollSent.setTimestamp(data + 1);
                timePollAckReceived.setTimestamp(data + 6);
                timeRangeSent.setTimestamp(data + 11);
                // (re-)compute range as two-way ranging is done
                computeRangeAsymmetric(); // CHOSEN RANGING ALGORITHM
                transmitRangeReport(timeComputedRange.getAsMicroSeconds());
                float distance = timeComputedRange.getAsMeters();
                Serial.print("Range: "); Serial.print(distance); Serial.print(" m");
                Serial.print("\t RX power: "); Serial.print(DW1000.getReceivePower()); Serial.print(" dBm");
                Serial.print("\t Sampling: "); Serial.print(samplingRate); Serial.println(" Hz");
                //Serial.print("FP power is [dBm]: "); Serial.print(DW1000.getFirstPathPower());
                //Serial.print("RX power is [dBm]: "); Serial.println(DW1000.getReceivePower());
                //Serial.print("Receive quality: "); Serial.println(DW1000.getReceiveQuality());
                // update sampling rate (each second)
                successRangingCount++;
                if (curMillis - rangingCountPeriod > 1000) {
                    samplingRate = (1000.0f * successRangingCount) / (curMillis - rangingCountPeriod);
                    rangingCountPeriod = curMillis;
                    successRangingCount = 0;
                }
            }
            else {
                transmitRangeFailed();
            }

            noteActivity();
        }
    }
}
#else

// messages used in the ranging protocol
// TODO replace by enum
#define POLL 0
#define POLL_ACK 1
#define RANGE 2
#define RANGE_REPORT 3
#define RANGE_FAILED 255
// message flow state
volatile byte expectedMsgId = POLL_ACK;
// message sent/received state
volatile boolean sentAck = false;
volatile boolean receivedAck = false;
// timestamps to remember
DW1000Time timePollSent;
DW1000Time timePollAckReceived;
DW1000Time timeRangeSent;
// data buffer
#define LEN_DATA 16
byte data[LEN_DATA];
// watchdog and reset period
uint32_t lastActivity;
uint32_t resetPeriod = 250;
// reply times (same on both sides for symm. ranging)
uint16_t replyDelayTimeUS = 3000;

void noteActivity() {
    // update activity timestamp, so that we do not reach "resetPeriod"
    lastActivity = millis();
}

void transmitPoll() {
    DW1000.newTransmit();
    DW1000.setDefaults();
    data[0] = POLL;
    DW1000.setData(data, LEN_DATA);
    DW1000.startTransmit();
}

void resetInactive() {
    // tag sends POLL and listens for POLL_ACK
    expectedMsgId = POLL_ACK;
    transmitPoll();
    noteActivity();
}

void handleSent() {
    // status change on sent success
    sentAck = true;
}

void handleReceived() {
    // status change on received success
    receivedAck = true;
}

void transmitRange() {
    DW1000.newTransmit();
    DW1000.setDefaults();
    data[0] = RANGE;
    // delay sending the message and remember expected future sent timestamp
    DW1000Time deltaTime = DW1000Time(replyDelayTimeUS, DW1000Time::MICROSECONDS);
    timeRangeSent = DW1000.setDelay(deltaTime);
    timePollSent.getTimestamp(data + 1);
    timePollAckReceived.getTimestamp(data + 6);
    timeRangeSent.getTimestamp(data + 11);
    DW1000.setData(data, LEN_DATA);
    DW1000.startTransmit();
    //Serial.print("Expect RANGE to be sent @ "); Serial.println(timeRangeSent.getAsFloat());
}

void receiver() {
    DW1000.newReceive();
    DW1000.setDefaults();
    // so we don't need to restart the receiver manually
    DW1000.receivePermanently(true);
    DW1000.startReceive();
}

void setup() {
    // DEBUG monitoring
    Serial.begin(115200);
    Serial.println(F("### DW1000-arduino-ranging-tag ###"));
    // initialize the driver
    DW1000.begin(UWB_IRQ, UWB_RST);
    DW1000.select(UWB_CS);
    Serial.println("DW1000 initialized ...");
    // general configuration
    DW1000.newConfiguration();
    DW1000.setDefaults();
    DW1000.setDeviceAddress(2);
    DW1000.setNetworkId(10);
    DW1000.enableMode(DW1000.MODE_LONGDATA_RANGE_LOWPOWER);
    DW1000.commitConfiguration();
    Serial.println(F("Committed configuration ..."));
    // DEBUG chip info and registers pretty printed
    char msg[128];
    DW1000.getPrintableDeviceIdentifier(msg);
    Serial.print("Device ID: "); Serial.println(msg);
    DW1000.getPrintableExtendedUniqueIdentifier(msg);
    Serial.print("Unique ID: "); Serial.println(msg);
    DW1000.getPrintableNetworkIdAndShortAddress(msg);
    Serial.print("Network ID & Device Address: "); Serial.println(msg);
    DW1000.getPrintableDeviceMode(msg);
    Serial.print("Device mode: "); Serial.println(msg);
    // attach callback for (successfully) sent and received messages
    DW1000.attachSentHandler(handleSent);
    DW1000.attachReceivedHandler(handleReceived);
    // anchor starts by transmitting a POLL message
    receiver();
    transmitPoll();
    noteActivity();
}

void loop() {
    if (!sentAck && !receivedAck) {
        // check if inactive
        if (millis() - lastActivity > resetPeriod) {
            resetInactive();
        }
        return;
    }
    // continue on any success confirmation
    if (sentAck) {
        sentAck = false;
        byte msgId = data[0];
        if (msgId == POLL) {
            DW1000.getTransmitTimestamp(timePollSent);
            //Serial.print("Sent POLL @ "); Serial.println(timePollSent.getAsFloat());
        } else if (msgId == RANGE) {
            DW1000.getTransmitTimestamp(timeRangeSent);
            noteActivity();
        }
    }
    if (receivedAck) {
        receivedAck = false;
        // get message and parse
        DW1000.getData(data, LEN_DATA);
        byte msgId = data[0];
        if (msgId != expectedMsgId) {
            // unexpected message, start over again
            //Serial.print("Received wrong message # "); Serial.println(msgId);
            expectedMsgId = POLL_ACK;
            transmitPoll();
            return;
        }
        if (msgId == POLL_ACK) {
            DW1000.getReceiveTimestamp(timePollAckReceived);
            expectedMsgId = RANGE_REPORT;
            transmitRange();
            noteActivity();
        } else if (msgId == RANGE_REPORT) {
            expectedMsgId = POLL_ACK;
            float curRange;
            memcpy(&curRange, data + 1, 4);
            transmitPoll();
            noteActivity();
        } else if (msgId == RANGE_FAILED) {
            expectedMsgId = POLL_ACK;
            transmitPoll();
            noteActivity();
        }
    }
}
#endif
