// #include <Arduino.h>
// #include <U8g2lib.h> 

// // 配置U8g2库用于SSD1327控制器，96x96分辨率，硬件SPI
// // 参数依次为：旋转方向、片选引脚、数据命令引脚、复位引脚
// U8G2_SSD1327_SEEED_96X96_F_4W_HW_SPI u8g2(U8G2_R0, /* cs */ 6, /* dc */ 3, /* rst */ 4);


// void setup() {
//   Serial.begin(9600);
//   Serial0.begin(9600);
//   u8g2.setBusClock(8000000); // 设置SPI时钟为8MHz（需屏幕支持）
//   u8g2.setContrast(128); // 设置对比度（0-255，灰度屏需调整）
//   u8g2.setFont(u8g2_font_helvB08_tr); // 设置字体
//   u8g2.begin(); // 初始化显示屏
//   u8g2.clearBuffer();   // 清空缓冲区
// }

// void drawGrayBox(int x, int y, int w, int h, int level) {
//   for (int i = 0; i < level; i++) {
//     u8g2.drawFrame(x + i, y + i, w - 2 * i, h - 2 * i); // 层级越多灰度越深
//   }
// }

// void loop() {
//   // if (Serial.available()) {        // If anything comes in Serial (USB),
//   //   Serial0.write(Serial.read());  // read it and send it out Serial0 (pins 0 & 1)
//   // }
//   // if (Serial0.available()) {       // If anything comes in Serial0 (pins 0 & 1)
//   //   Serial.write(Serial0.read());  // read it and send it out Serial (USB)
//   // }

//   u8g2.clearBuffer();
//   // 示例1：显示文本（16级灰度需使用支持灰度的字体）
//   u8g2.drawStr(0, 20, "Hello SSD1327"); // 在坐标(0,20)绘制文本
//   // 示例2：绘制灰度图形（矩形框和填充框）
//   u8g2.drawFrame(10, 30, 40, 20);      // 空心矩形（x,y,宽,高）
//   u8g2.drawBox(60, 30, 40, 20);        // 实心矩形
//   // 示例3：利用灰度特性绘制渐变图形（通过重复绘制实现）
//   for (int i = 0; i < 16; i++) {
//     u8g2.drawCircle(48 + i, 70 + i, 10); // 绘制重叠圆形模拟灰度
//   }
//   // 绘制中灰色方块
//   drawGrayBox(10, 50, 30, 30, 16);
//   u8g2.sendBuffer();
//   delay(1000);
// }


#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1327.h>

// 定义SPI接口使用的引脚
#define CS_PIN    6  // 片选
#define DC_PIN    3  // 数据/命令
#define RST_PIN   4  // 复位

// 初始化SSD1327对象，使用硬件SPI
// Adafruit_SSD1327( width, height, &SPI, dc_pin, rst_pin, cs_pin );
Adafruit_SSD1327 display(96, 96, &SPI, DC_PIN, RST_PIN, CS_PIN);


#define NUMFLAKES 10
#define XPOS 0
#define YPOS 1
#define DELTAY 2


#define LOGO16_GLCD_HEIGHT 16 
#define LOGO16_GLCD_WIDTH  16 
static const unsigned char PROGMEM logo16_glcd_bmp[] =
{ B00000000, B11000000,
  B00000001, B11000000,
  B00000001, B11000000,
  B00000011, B11100000,
  B11110011, B11100000,
  B11111110, B11111000,
  B01111110, B11111111,
  B00110011, B10011111,
  B00011111, B11111100,
  B00001101, B01110000,
  B00011011, B10100000,
  B00111111, B11100000,
  B00111111, B11110000,
  B01111100, B11110000,
  B01110000, B01110000,
  B00000000, B00110000 };



void testdrawbitmap(const uint8_t* bitmap, uint8_t w, uint8_t h) {
  uint8_t icons[NUMFLAKES][3];
  randomSeed(666);     // whatever seed

  // initialize
  for (uint8_t f = 0; f < NUMFLAKES; f++) {
    icons[f][XPOS] = random(display.width());
    icons[f][YPOS] = 0;
    icons[f][DELTAY] = random(5) + 1;

    Serial.print("x: ");
    Serial.print(icons[f][XPOS], DEC);
    Serial.print(" y: ");
    Serial.print(icons[f][YPOS], DEC);
    Serial.print(" dy: ");
    Serial.println(icons[f][DELTAY], DEC);
  }

  while (1) {
    // draw each icon
    for (uint8_t f = 0; f < NUMFLAKES; f++) {
      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, f + 1);
    }
    display.display();
    delay(200);

    // then erase it + move it
    for (uint8_t f = 0; f < NUMFLAKES; f++) {
      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, SSD1327_BLACK);
      // move it
      icons[f][YPOS] += icons[f][DELTAY];
      // if its gone, reinit
      if (icons[f][YPOS] > display.height()) {
        icons[f][XPOS] = random(display.width());
        icons[f][YPOS] = 0;
        icons[f][DELTAY] = random(5) + 1;
      }
    }
  }
}


void testdrawchar(void) {
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(16, 0);

  for (uint8_t i = 0; i < 168; i++) {
    if (i == '\n') continue;
    display.write(i);
    if ((i > 0) && (i % 21 == 0))
      display.println();
  }
  display.display();
}

void testdrawcircle(void) {
  for (uint8_t i = 0; i < display.height(); i += 2) {
    display.drawCircle(display.width() / 2 + 8, display.height() / 2, i, i % 15 + 1);
    display.display();
  }
}

void testfillrect(void) {
  uint8_t color = 1;
  for (uint8_t i = 0; i < display.height() / 2; i += 3) {
    // alternate colors
    display.fillRect(i + 16, i, display.width() - i * 2, display.height() - i * 2, i % 15 + 1);
    display.display();
    color++;
  }
}

void testdrawtriangle(void) {
  for (uint16_t i = 0; i < min(display.width(), display.height()) / 2; i += 5) {
    display.drawTriangle(display.width() / 2 + 8, display.height() / 2 - i,
      display.width() / 2 + 8 - i, display.height() / 2 + i,
      display.width() / 2 + 8 + i, display.height() / 2 + i, i % 15 + 1);
    display.display();
  }
}

void testfilltriangle(void) {
  // uint8_t color = SSD1327_WHITE;
  for (int16_t i = min(display.width(), display.height()) / 2; i > 0; i -= 5) {
    display.fillTriangle(display.width() / 2 + 8, display.height() / 2 - i,
      display.width() / 2 + 8 - i, display.height() / 2 + i,
      display.width() / 2 + 8 + i, display.height() / 2 + i, i % 15 + 1);
    display.display();
  }
}

void testdrawroundrect(void) {
  for (uint8_t i = 0; i < display.height() / 3 - 2; i += 2) {
    display.drawRoundRect(i + 16, i, display.width() - 2 * i, display.height() - 2 * i, display.height() / 4, i % 15 + 1);
    display.display();
  }
}

void testfillroundrect(void) {
  // uint8_t color = SSD1327_WHITE;
  for (uint8_t i = 0; i < display.height() / 3 - 2; i += 2) {
    display.fillRoundRect(i + 16, i, display.width() - 2 * i, display.height() - 2 * i, display.height() / 4, i % 15 + 1);
    display.display();
  }
}

void testdrawrect(void) {
  for (uint8_t i = 0; i < display.height() / 2; i += 2) {
    display.drawRect(i + 16, i, display.width() - 2 * i, display.height() - 2 * i, i % 15 + 1);
    display.display();
  }
}

void testdrawline() {
  for (uint8_t i = 0; i < display.width(); i += 4) {
    display.drawLine(16, 0, i, display.height() - 1, SSD1327_WHITE);
    display.display();
  }
  for (uint8_t i = 0; i < display.height(); i += 4) {
    display.drawLine(16, 0, display.width() - 1, i, SSD1327_WHITE);
    display.display();
  }
  delay(250);

  display.clearDisplay();
  for (uint8_t i = 0; i < display.width(); i += 4) {
    display.drawLine(16, display.height() - 1, i, 0, SSD1327_WHITE);
    display.display();
  }
  for (int8_t i = display.height() - 1; i >= 0; i -= 4) {
    display.drawLine(16, display.height() - 1, display.width() - 1, i, SSD1327_WHITE);
    display.display();
  }
  delay(250);

  display.clearDisplay();
  for (int8_t i = display.width() - 1; i >= 0; i -= 4) {
    display.drawLine(display.width() - 1 + 16, display.height() - 1, i, 0, SSD1327_WHITE);
    display.display();
  }
  for (int8_t i = display.height() - 1; i >= 0; i -= 4) {
    display.drawLine(display.width() - 1 + 16, display.height() - 1, 0, i, SSD1327_WHITE);
    display.display();
  }
  delay(250);

  display.clearDisplay();
  for (uint8_t i = 0; i < display.height(); i += 4) {
    display.drawLine(display.width() - 1 + 16, 0, 0, i, SSD1327_WHITE);
    display.display();
  }
  for (uint8_t i = 0; i < display.width(); i += 4) {
    display.drawLine(display.width() - 1 + 16, 0, i, display.height() - 1, SSD1327_WHITE);
    display.display();
  }
  delay(250);
}


void setup() {
  Serial.begin(9600);
  //while (! Serial) delay(100);
  Serial.println("SSD1327 OLED test");

  if (!display.begin()) {
    Serial.println("Unable to initialize OLED");
    while (1) yield();
  }
  display.clearDisplay();
  display.display();

  // draw many lines
  testdrawline();
  display.display();
  delay(1000);
  display.clearDisplay();

  // draw rectangles
  testdrawrect();
  display.display();
  delay(1000);
  display.clearDisplay();

  // draw multiple rectangles
  testfillrect();
  display.display();
  delay(1000);
  display.clearDisplay();

  // draw mulitple circles
  testdrawcircle();
  display.display();
  delay(1000);
  display.clearDisplay();

  // draw a SSD1327_WHITE circle, 10 pixel radius
  display.fillCircle(display.width() / 2 + 8, display.height() / 2, 10, SSD1327_WHITE);
  display.display();
  delay(1000);
  display.clearDisplay();

  testdrawroundrect();
  delay(1000);
  display.clearDisplay();

  testfillroundrect();
  delay(1000);
  display.clearDisplay();

  testdrawtriangle();
  delay(1000);
  display.clearDisplay();

  testfilltriangle();
  delay(1000);
  display.clearDisplay();

  // draw the first ~12 characters in the font
  testdrawchar();
  display.display();
  delay(1000);
  display.clearDisplay();

  for (uint8_t rot = 0; rot < 4; rot++) {
    display.setRotation(rot);
    display.clearDisplay();
    // text display tests
    display.setTextSize(1);
    display.setTextColor(SSD1327_WHITE);
    display.setCursor(16, 0);
    display.println("Hello, world!");
    display.setTextColor(SSD1327_BLACK, SSD1327_WHITE); // 'inverted' text
    display.println(3.141592);
    display.setTextSize(2);
    display.setTextColor(SSD1327_WHITE);
    display.print("0x"); display.println(0xDEADBEEF, HEX);
    display.display();
    delay(1000);
  }

  display.setRotation(0);

  // miniature bitmap display
  display.clearDisplay();
  display.drawBitmap(30, 16, logo16_glcd_bmp, 16, 16, 1);
  display.display();

  // invert the display
  display.invertDisplay(true);
  delay(1000);
  display.invertDisplay(false);
  delay(1000);

  // draw a bitmap icon and 'animate' movement
  testdrawbitmap(logo16_glcd_bmp, LOGO16_GLCD_HEIGHT, LOGO16_GLCD_WIDTH);
}

void loop() {
}
